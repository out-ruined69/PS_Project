nr_corzi <- sum(c1*c1 + c2*c2 >  (r/2)*(r/2))
print(nr_corzi)
prob <- nr_corzi / n
print(prob)
df <- data.frame(r1,r2)
ggplot(df) +
geom_segment(aes(x = r1, y = r2, xend = 0, yend = 0), color = "blue", size = 0.5) +
geom_point(aes(x=c1, y=c2), data=df, size=2, shape=1, color="red", fill = "red") +
annotate("path",x=0+r*cos(seq(0,2*pi,length.out=100)),y=0+r*sin(seq(0,2*pi,length.out=100)), color="red", size=1,5)+
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = -r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(y = -r/2, x = -r*(sqrt(3)/2), yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
xlim(-r, r) + ylim(-r, r) +
ggtitle("Metoda 2 (Am generat doar centrele corzilor pentru simplitate)",prob) +
xlab("X") + ylab("Y")
output$plot <- renderPlot({ g }, height = 600, width = 600)
})
}
# Run the Shiny app
shinyApp(ui, server)
runApp('test2.r')
library(shiny); runApp('test3.r')
library(shiny); runApp('test2.r')
#METODA 1
#remove.packages("ggplot2")
#install ggplot2
#install.packages("ggplot2")
#install.packages('ggplot2')
library(ggplot2)
r <- 4
n <- 1000
mx <- runif(n,-r,r)
my <- runif(n,-sqrt(r*r-mx*mx),sqrt(r*r-mx*mx))
nr_corzi <- sum((mx*mx+my*my)<(r/2)*(r/2))
# Calculam probabilitatea
prob <- nr_corzi / n
print(prob)
df <- data.frame(mx, my)
ggplot(df) +
#geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = "blue", size = 0.5) +
geom_point(aes(x=mx, y=my), data=df, size=2, shape=1, color="red", fill = "red") +
annotate("path",x=0+r*cos(seq(0,2*pi,length.out=100)),y=0+r*sin(seq(0,2*pi,length.out=100)), color="red", size=1,5)+
annotate("path",x=0+(r/2)*cos(seq(0,2*pi,length.out=100)),y=0+(r/2)*sin(seq(0,2*pi,length.out=100)), color="pink", size=1,5)+
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = -r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(y = -r/2, x = -r*(sqrt(3)/2), yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
xlim(-r, r) + ylim(-r, r) +
ggtitle("Metoda 3", prob)
xlab("X") + ylab("Y")
#METODA 1
#remove.packages("ggplot2")
#install ggplot2
#install.packages("ggplot2")
#install.packages('ggplot2')
library(ggplot2)
r <- 4
n <- 1000
mx <- runif(n,-r,r)
my <- runif(n,-sqrt(r*r-mx*mx),sqrt(r*r-mx*mx))
nr_corzi <- sum((mx*mx+my*my)<(r/2)*(r/2))
# Calculam probabilitatea
prob <- nr_corzi / n
print(prob)
df <- data.frame(mx, my)
ggplot(df) +
#geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = "blue", size = 0.5) +
geom_point(aes(x=mx, y=my), data=df, size=2, shape=1, color="red", fill = "red") +
annotate("path",x=0+r*cos(seq(0,2*pi,length.out=100)),y=0+r*sin(seq(0,2*pi,length.out=100)), color="red", size=1,5)+
annotate("path",x=0+(r/2)*cos(seq(0,2*pi,length.out=100)),y=0+(r/2)*sin(seq(0,2*pi,length.out=100)), color="pink", size=1,5)+
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = -r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(y = -r/2, x = -r*(sqrt(3)/2), yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
xlim(-r, r) + ylim(-r, r) +
ggtitle("Metoda 3", prob)
xlab("X") + ylab("Y")
runApp('test3.r')
library(shiny); runApp('test3.r')
library(shiny); runApp('test3.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
library(shiny); runApp('test.r')
runApp('test2.r')
runApp('test3.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
library(shiny); runApp('test.r')
library(shiny); runApp('test.r')
runApp('test.r')
runApp('test.r')
runApp('test.r')
library(shiny); runApp('test.r')
---
title: "Proiect"
runApp('test.r')
runApp('test.r')
runApp('test.r')
library(ggplot2)
r <- 4
n <- 10
#se genereaza aleator coarda
#se genereaza un unghi cu o masura random
unghi1 <- runif(n, 0, 2 * pi)
#se gasesc punctele corespunzatoare acelui unghi
x1 <- r * cos(unghi1)
y1 <- r * sin(unghi1)
unghi2 <- runif(n, 0, 2 * pi)
x2 <- r * cos(unghi2)
y2 <- r * sin(unghi2)
# Se calculeaza lungimea corzii folosind formula
lung_coarda <- sqrt((x1 - x2)^2 + (y1 - y2)^2)
# Calculam cate corzi
nr_corzi <- sum(lung_coarda >  r * sqrt(3))
# Calculam probabilitatea
prob <- nr_corzi / n
print(prob)
#se face graful
df <- data.frame(x1, y1, x2, y2)
ggplot(df) +
annotate("path",x=0+r*cos(seq(0,2*pi,length.out=100)),y=0+r*sin(seq(0,2*pi,length.out=100)), color="red", size=1,5)+
geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = "blue", size = 0.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = -r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(y = -r/2, x = -r*(sqrt(3)/2), yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
xlim(-r, r) + ylim(-r, r) +
ggtitle("Metoda 1",prob) +
xlab("X") + ylab("Y")
library(ggplot2)
r <- 4
n <- 10
#se genereaza aleator coarda
#se genereaza un unghi cu o masura random
unghi1 <- runif(n, 0, 2 * pi)
#se gasesc punctele corespunzatoare acelui unghi
x1 <- r * cos(unghi1)
y1 <- r * sin(unghi1)
unghi2 <- runif(n, 0, 2 * pi)
x2 <- r * cos(unghi2)
y2 <- r * sin(unghi2)
# Se calculeaza lungimea corzii folosind formula
lung_coarda <- sqrt((x1 - x2)^2 + (y1 - y2)^2)
# Calculam cate corzi
nr_corzi <- sum(lung_coarda >  r * sqrt(3))
# Calculam probabilitatea
prob <- nr_corzi / n
print(prob)
#se face graful
df <- data.frame(x1, y1, x2, y2)
ggplot(df) +
annotate("path",x=0+r*cos(seq(0,2*pi,length.out=100)),y=0+r*sin(seq(0,2*pi,length.out=100)), color="red", size=1,5)+
geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = "blue", size = 0.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = -r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(y = -r/2, x = -r*(sqrt(3)/2), yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
xlim(-r, r) + ylim(-r, r) +
ggtitle("Metoda 1",prob) +
xlab("X") + ylab("Y")
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
r <- 4
n <- 10
#se genereaza aleator coarda
#se genereaza un unghi cu o masura random
unghi1 <- runif(n, 0, 2 * pi)
#se gasesc punctele corespunzatoare acelui unghi
x1 <- r * cos(unghi1)
y1 <- r * sin(unghi1)
unghi2 <- runif(n, 0, 2 * pi)
x2 <- r * cos(unghi2)
y2 <- r * sin(unghi2)
# Se calculeaza lungimea corzii folosind formula
lung_coarda <- sqrt((x1 - x2)^2 + (y1 - y2)^2)
# Calculam cate corzi
nr_corzi <- sum(lung_coarda >  r * sqrt(3))
# Calculam probabilitatea
prob <- nr_corzi / n
print(prob)
#se face graful
df <- data.frame(x1, y1, x2, y2)
ggplot(df) +
annotate("path",x=0+r*cos(seq(0,2*pi,length.out=100)),y=0+r*sin(seq(0,2*pi,length.out=100)), color="red", size=1,5)+
geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = "blue", size = 0.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = -r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(y = -r/2, x = -r*(sqrt(3)/2), yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
xlim(-r, r) + ylim(-r, r) +
ggtitle("Metoda 1",prob) +
xlab("X") + ylab("Y")
library(ggplot2)
r <- 4
n <- 10
#se genereaza aleator coarda
#se genereaza un unghi cu o masura random
unghi1 <- runif(n, 0, 2 * pi)
#se gasesc punctele corespunzatoare acelui unghi
x1 <- r * cos(unghi1)
y1 <- r * sin(unghi1)
unghi2 <- runif(n, 0, 2 * pi)
x2 <- r * cos(unghi2)
y2 <- r * sin(unghi2)
# Se calculeaza lungimea corzii folosind formula
lung_coarda <- sqrt((x1 - x2)^2 + (y1 - y2)^2)
# Calculam cate corzi
nr_corzi <- sum(lung_coarda >  r * sqrt(3))
# Calculam probabilitatea
prob <- nr_corzi / n
print(prob)
#se face graful
df <- data.frame(x1, y1, x2, y2)
ggplot(df) +
annotate("path",x=0+r*cos(seq(0,2*pi,length.out=100)),y=0+r*sin(seq(0,2*pi,length.out=100)), color="red", size=1,5)+
geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = "blue", size = 0.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = -r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(y = -r/2, x = -r*(sqrt(3)/2), yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
xlim(-r, r) + ylim(-r, r) +
ggtitle("Metoda 1",prob) +
xlab("X") + ylab("Y")
# Define the radius of the circle
r <- 5
n <- 1000
#se creeaza o raza random
unghi1 <- runif(n, 0, 2 * pi)
#se gasesc punctele corespunzatoare acelui unghi
r1 <- r * cos(unghi1)
r2 <- r * sin(unghi1)
# Define the radius of the circle
r <- 5
n <- 1000
#se creeaza o raza random
unghi1 <- runif(n, 0, 2 * pi)
#se gasesc punctele corespunzatoare acelui unghi
r1 <- r * cos(unghi1)
r2 <- r * sin(unghi1)
c1 <- ifelse(r1 > 0,  runif(n,0,r1), runif(n,r1,0))
print(c1)
print(c2)
c2 <- (r2 * c1)/r1
nr_corzi <- sum(c1*c1 + c2*c2 >  (r/2)*(r/2))
print(nr_corzi)
prob <- nr_corzi / n
print(prob)
df <- data.frame(r1,r2)
ggplot(df) +
geom_segment(aes(x = r1, y = r2, xend = 0, yend = 0), color = "blue", size = 0.5) +
geom_point(aes(x=c1, y=c2), data=df, size=2, shape=1, color="red", fill = "red") +
annotate("path",x=0+r*cos(seq(0,2*pi,length.out=100)),y=0+r*sin(seq(0,2*pi,length.out=100)), color="red", size=1,5)+
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = -r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(y = -r/2, x = -r*(sqrt(3)/2), yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
xlim(-r, r) + ylim(-r, r) +
ggtitle("Metoda 2 (Am generat doar centrele corzilor pentru simplitate)",prob) +
xlab("X") + ylab("Y")
# Define the radius of the circle
r <- 5
n <- 1000
#se creeaza o raza random
unghi1 <- runif(n, 0, 2 * pi)
#se gasesc punctele corespunzatoare acelui unghi
r1 <- r * cos(unghi1)
r2 <- r * sin(unghi1)
c1 <- ifelse(r1 > 0,  runif(n,0,r1), runif(n,r1,0))
print(c1)
print(c2)
c2 <- (r2 * c1)/r1
nr_corzi <- sum(c1*c1 + c2*c2 >  (r/2)*(r/2))
print(nr_corzi)
prob <- nr_corzi / n
print(prob)
df <- data.frame(r1,r2)
ggplot(df) +
geom_segment(aes(x = r1, y = r2, xend = 0, yend = 0), color = "blue", size = 0.5) +
geom_point(aes(x=c1, y=c2), data=df, size=2, shape=1, color="red", fill = "red") +
annotate("path",x=0+r*cos(seq(0,2*pi,length.out=100)),y=0+r*sin(seq(0,2*pi,length.out=100)), color="red", size=1,5)+
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = -r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(y = -r/2, x = -r*(sqrt(3)/2), yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
xlim(-r, r) + ylim(-r, r) +
ggtitle("Metoda 2 (Am generat doar centrele corzilor pentru simplitate)",prob) +
xlab("X") + ylab("Y")
---
title: "Proiect"
# Monty Hall simulation function
monty_hall <- function(n_sim, player_strategy) {
wins <- 0
for (i in 1:n_sim) {
doors <- c(1, 2, 3)
prize_door <- sample(doors, 1)
player_choice <- sample(doors, 1)
if (player_strategy == "switch") {
if(player_choice != prize_door)
wins <- wins + 1
}
else
wins <- wins + (player_choice == prize_door)
}
return(wins/n_sim)
}
# Simulation parameters
n_sim <- 100000
# Probability of winning with "stay" strategy
stay_win_prob <- monty_hall(n_sim, "stay")
# Probability of winning with "switch" strategy
switch_win_prob <- monty_hall(n_sim, "switch")
# Display results
cat("Probability of winning with 'stay' strategy: ", stay_win_prob, "\n")
cat("Probability of winning with 'switch' strategy: ", switch_win_prob, "\n")
library(shiny)
library(ggplot2)
# METODA 1
# UI definition
ui <- fluidPage(
numericInput("r", "Radius:",1),
numericInput("n", "Nr experimente:",10),
plotOutput("plot")
)
# Server definition
server <- function(input, output) {
observe({
# Monty Hall simulation function
monty_hall <- function(n_sim, player_strategy) {
wins <- 0
for (i in 1:n_sim) {
doors <- c(1, 2, 3)
prize_door <- sample(doors, 1)
player_choice <- sample(doors, 1)
if (player_strategy == "switch") {
if(player_choice != prize_door)
wins <- wins + 1
}
else
wins <- wins + (player_choice == prize_door)
}
return(wins/n_sim)
}
# Simulation parameters
n_sim <- 100000
# Probability of winning with "stay" strategy
stay_win_prob <- monty_hall(n_sim, "stay")
# Probability of winning with "switch" strategy
switch_win_prob <- monty_hall(n_sim, "switch")
# Display results
cat("Probability of winning with 'stay' strategy: ", stay_win_prob, "\n")
cat("Probability of winning with 'switch' strategy: ", switch_win_prob, "\n")
})
}
# Run the Shiny app
shinyApp(ui, server)
runApp('monty_hall.R')
runApp('monty_hall.R')
runApp('test.r')
library(shiny); runApp('test.r')
library(shiny); runApp('test.r')
---
title: "Proiect"
---
title: "Proiect"
---
title: "Proiect"
title: "Proiect"
runApp('simpson.R')
runApp('simpson.R')
Enunțul Paradoxului Lui Bertrand este următorul:
---
title: "Proiect"
---
title: "Proiect"
---
title: "Proiect"
---
title: "Proiect"
---
title: "Proiect"
library(shiny); runApp('test.r')
---
title: "Proiect"
#METODA 1
#remove.packages("ggplot2")
#install ggplot2
#install.packages("ggplot2")
#install.packages('ggplot2')
library(ggplot2)
r <- 4
n <- 100
#se genereaza aleator coarda
#se genereaza un unghi cu o masura random
unghi1 <- runif(n, 0, 2 * pi)
#se gasesc punctele corespunzatoare acelui unghi
x1 <- r * cos(unghi1)
y1 <- r * sin(unghi1)
unghi2 <- runif(n, 0, 2 * pi)
x2 <- r * cos(unghi2)
y2 <- r * sin(unghi2)
# Se calculeaza lungimea corzii folosind formula
lung_coarda <- sqrt((x1 - x2)^2 + (y1 - y2)^2)
# Calculam cate corzi
nr_corzi <- sum(lung_coarda >  r * sqrt(3))
# Calculam probabilitatea
prob <- nr_corzi / n
print(prob)
#se face graful
df <- data.frame(x1, y1, x2, y2)
ggplot(df) +
annotate("path",x=0+r*cos(seq(0,2*pi,length.out=100)),y=0+r*sin(seq(0,2*pi,length.out=100)), color="red", size=1,5)+
geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = "blue", size = 0.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = -r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(y = -r/2, x = -r*(sqrt(3)/2), yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
xlim(-r, r) + ylim(-r, r) +
ggtitle("Metoda 1",prob) +
xlab("X") + ylab("Y")
# Define the radius of the circle
r <- 5
n <- 1000
#se creeaza o raza random
unghi1 <- runif(n, 0, 2 * pi)
#se gasesc punctele corespunzatoare acelui unghi
r1 <- r * cos(unghi1)
r2 <- r * sin(unghi1)
c1 <- ifelse(r1 > 0,  runif(n,0,r1), runif(n,r1,0))
print(c1)
print(c2)
c2 <- (r2 * c1)/r1
nr_corzi <- sum(c1*c1 + c2*c2 >  (r/2)*(r/2))
print(nr_corzi)
prob <- nr_corzi / n
print(prob)
df <- data.frame(r1,r2)
ggplot(df) +
geom_segment(aes(x = r1, y = r2, xend = 0, yend = 0), color = "blue", size = 0.5) +
geom_point(aes(x=c1, y=c2), data=df, size=2, shape=1, color="red", fill = "red") +
annotate("path",x=0+r*cos(seq(0,2*pi,length.out=100)),y=0+r*sin(seq(0,2*pi,length.out=100)), color="red", size=1,5)+
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = -r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(y = -r/2, x = -r*(sqrt(3)/2), yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
xlim(-r, r) + ylim(-r, r) +
ggtitle("Metoda 2 (Am generat doar centrele corzilor pentru simplitate)",prob) +
xlab("X") + ylab("Y")
# Define the radius of the circle
r <- 5
n <- 1000
library(ggplot2)
#se creeaza o raza random
unghi1 <- runif(n, 0, 2 * pi)
#se gasesc punctele corespunzatoare acelui unghi
r1 <- r * cos(unghi1)
r2 <- r * sin(unghi1)
c1 <- ifelse(r1 > 0,  runif(n,0,r1), runif(n,r1,0))
print(c1)
print(c2)
c2 <- (r2 * c1)/r1
nr_corzi <- sum(c1*c1 + c2*c2 >  (r/2)*(r/2))
print(nr_corzi)
prob <- nr_corzi / n
print(prob)
df <- data.frame(r1,r2)
ggplot(df) +
geom_segment(aes(x = r1, y = r2, xend = 0, yend = 0), color = "blue", size = 0.5) +
geom_point(aes(x=c1, y=c2), data=df, size=2, shape=1, color="red", fill = "red") +
annotate("path",x=0+r*cos(seq(0,2*pi,length.out=100)),y=0+r*sin(seq(0,2*pi,length.out=100)), color="red", size=1,5)+
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = -r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(y = -r/2, x = -r*(sqrt(3)/2), yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
xlim(-r, r) + ylim(-r, r) +
ggtitle("Metoda 2 (Am generat doar centrele corzilor pentru simplitate)",prob) +
xlab("X") + ylab("Y")
#METODA 1
#remove.packages("ggplot2")
#install ggplot2
#install.packages("ggplot2")
#install.packages('ggplot2')
library(ggplot2)
r <- 4
n <- 1000
mx <- runif(n,-r,r)
my <- runif(n,-sqrt(r*r-mx*mx),sqrt(r*r-mx*mx))
nr_corzi <- sum((mx*mx+my*my)<(r/2)*(r/2))
# Calculam probabilitatea
prob <- nr_corzi / n
print(prob)
df <- data.frame(mx, my)
ggplot(df) +
#geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = "blue", size = 0.5) +
geom_point(aes(x=mx, y=my), data=df, size=2, shape=1, color="red", fill = "red") +
annotate("path",x=0+r*cos(seq(0,2*pi,length.out=100)),y=0+r*sin(seq(0,2*pi,length.out=100)), color="red", size=1,5)+
annotate("path",x=0+(r/2)*cos(seq(0,2*pi,length.out=100)),y=0+(r/2)*sin(seq(0,2*pi,length.out=100)), color="pink", size=1,5)+
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(x = 0, y = r, yend = -r/2, xend = -r*(sqrt(3)/2)), color = "purple", size = 1.5) +
geom_segment(aes(y = -r/2, x = -r*(sqrt(3)/2), yend = -r/2, xend = r*(sqrt(3)/2)), color = "purple", size = 1.5) +
xlim(-r, r) + ylim(-r, r) +
ggtitle("Metoda 3", prob)
xlab("X") + ylab("Y")
library(shiny); runApp('monty_hall.R')
runApp('monty_hall.R')
runApp('simpson.R')
runApp('simpson.R')
runApp('test.r')
